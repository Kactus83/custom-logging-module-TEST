"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggingService = void 0;
const LoggerStyleService_1 = require("./services/styles/LoggerStyleService");
const StyleConfigManager_1 = require("./services/styles/StyleConfigManager");
class LoggingService {
    // Constructeur privé pour empêcher l'instanciation directe
    constructor() {
        this.servicesMetadata = [];
    }
    // Méthode pour obtenir l'instance singleton
    static getInstance() {
        if (!LoggingService.instance) {
            LoggingService.instance = new LoggingService();
        }
        return LoggingService.instance;
    }
    // Initialisation du service de log avec configuration
    init(loggerConfig) {
        this.loggerConfig = loggerConfig;
        StyleConfigManager_1.StyleConfigManager.getInstance().updateStyleConfig(loggerConfig);
        this.loggerStyleService = new LoggerStyleService_1.LoggerStyleService();
    }
    // Méthode statique pour initialiser le service de log
    static initialize(loggerConfig, loggerStylesConfig) {
        const instance = LoggingService.getInstance();
        instance.init(loggerConfig);
    }
    // Vérifie si le service de log a été initialisé
    static isInitialized() {
        const instance = LoggingService.getInstance();
        return !!instance.loggerConfig;
    }
    // Mise à jour de la configuration du service de log
    updateConfig(loggerConfig) {
        this.init(loggerConfig);
    }
    // Méthode pour logger les messages
    log(metadata, level, message) {
        if (!this.loggerConfig || !this.loggerStyleService) {
            throw new Error("LoggingService is not initialized. Call 'init' method before logging.");
        }
        if (this.shouldLog(level)) {
            this.registerServiceIfNeeded(metadata);
            const storedMetadata = this.findServiceMetadata(metadata.serviceName);
            if (storedMetadata) {
                const formattedMessage = this.loggerStyleService.formatMessage(storedMetadata, level, message);
                this.processConsoleLog(formattedMessage);
            }
        }
    }
    // Autres méthodes privées pour le fonctionnement interne du service de log
    shouldLog(level) {
        return this.loggerConfig ? level >= this.loggerConfig.logLevel : false;
    }
    registerServiceIfNeeded(metadata) {
        if (!this.findServiceMetadata(metadata.serviceName)) {
            this.servicesMetadata.push(metadata);
        }
    }
    findServiceMetadata(serviceName) {
        return this.servicesMetadata.find(service => service.serviceName === serviceName);
    }
    processConsoleLog(message) {
        console.log(message);
    }
}
exports.LoggingService = LoggingService;
LoggingService.instance = null;
//# sourceMappingURL=LoggingService.js.map